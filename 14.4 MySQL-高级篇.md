<a id="back-top"></a>
[TOC]
### 1. 视图
> 思考一个问题：之前已上线的项目中已多处使用数据库的sql语句，现在因为需求变化等原因，数据库要做点改变，为了保证正常查询到数据，之前的功能代码也要进行多处更改，维护起来显然特别麻烦。这肯定是个问题，你会怎么解决呢？

> 答：解决办法：定义视图。（请带着疑惑继续看下去）

#### 1.1 视图是什么？
* 简言之，**视图**是一个sql语句生成的一张虚表！
* 语法：**`create view 视图名称 as select语句`**
* 注意：建议上述sql语句的**视图名称**建议以 **`v_`** 开头；
* **视图是对若干张基本表的引用，是一张虚表；这条sql语句执行的结果不存储具体的数据（基本表数据发生了改变，视图也会跟着改变）**
* 删除视图：`drop view 视图名称`

#### 1.2 视图的一个重要用途
* 我们已知**视图是一张虚表**，它的重要用途就是**查询**
```
-- 以 students 表 和classes 表为例
-- 创建 一张整合students 和 classes 整合的虚表
create view v_students_classes as select * from students as s left join classes as c where c.id = s.cls_id;

-- 使用视图
select * from v_students_classes;
```
#### 1.3 视图的优点
* 提高重用性，创建一张虚表，有需要的地方都可以使用这张表；
* 当需要重构数据库时，不需要修改程序中的sql语句；
* 不同用户使用不同的视图，提高数据安全性；
* 将多张基础表的数据整理到一张表，可直观查看数据。

### 2. 事务
> **事务** 在日常的代码程序中经常被使用；

#### 2.1 基本概念及特性
* 所谓**事务**，它是一个操作序列（即几个sql语句），这些操作要么都执行，要么都不执行，事务是一个不可分割的工作单位。
```
这里举一个银行转账的例子辅助理解：
小明向小东转账1000元
那么后台系统操作sql语句需要做以下几件事：
（1）检查小明的账户余额 >= 1000 元
（2）小明账户扣除 1000 元
（3）小东账户增加 1000 元

上述例子中，后台系统需要做的三件事就组成一个事务，只有这三步全部完成，
才能算转账成功，否则就会回滚到转账之前，提醒小明转账失败。
```
* 事务的四大特性(简称ACID)
  * 原子性
  * 一致性
  * 隔离性
  * 持久性
> 还是以上述的银行转账为例
```sql
- 1. 开启事务 begin 或者 start transaction;
start transaction;

- 2. 检查小明的账户余额 >= 1000
select * from v_bank_demo where id=141234;

- 3. 小明账户扣除1000
update table bank_demo set money = money-1000 where id=141234;

- 4. 小东账户增加1000元
update table bank_demo set money = money+1000 where id=214234;

- 5. 提交
commit;
```
* 上述的第2~4步，是一个不可分割的最小单元，这就是**原子性**的体现；
* 上述的第2~4步，具有‘同生共死’的特点，这就是**一致性**；
* 假设有A和B两个用户同时操作数据库，当A执行了上述1~4步，如果不执行第5步，B无法看到A对数据库的操作，这就体现为**隔离性**；
* 当执行第5步后，对数据库的操作会写入磁盘永久存储，这就是**持久性**。

#### 2.2 提交 `commit`
* 将缓存中的数据变更维护到物理表中；
* 使用`commit;`命令；

#### 2.3 回滚 `rollback`
* 放弃缓存中变更的数据;
* 使用`rollback;`命令；

### 3. 索引
> 数据的更新及插入操作很少出现性能问题，最多、最易出现问题的还是查询操作，因此对查询语句的优化是解决性能问题的重点。

> 提出一个问题：当遇到查询数据量很大时，查询速度会非常慢，如何解决？  答：索引。

#### 3.1 索引是什么
* 索引是一种特殊的文件，它们包含着对数据表里所有记录的引用指针。
* 通俗的说，数据库索引好比是一本书前面的目录，能加快数据库的查询速度。

#### 3.2 索引的目的
* 提升查询效率

#### 3.3 索引的使用
##### 3.3.1 查看索引
`show index from 表名;`

##### 3.3.2 创建索引
`create index 索引名称 on 表名(字段名称(长度));`
* 如果指定字段是字符串，需要指定长度，建议长度与定义字段时的长度一致；
* 字段类型如果不是字符串，可以不填写长度部分。

##### 3.3.3 删除索引
* `drop index 索引名称 on 表名;`

#### 3.4 索引demo
* 创建测试库及表
```
- 创建测试库
create database db_test charset=utf8;

- 创建测试表
create table tb_test(title varchar(10));
```

* 使用python程序，引入pymysql模块，向tb_test表中加入十万条数据
```python
from pymysql import connect

def main():
    # 创建Connection连接
    conn = connect(host='localhost',port=3306,database='db_test',user='root',password='mysql',charset='utf8')
    # 获得Cursor对象
    cursor = conn.cursor()
    # 插入10万次数据
    for i in range(100000):
        cursor.execute("insert into tb_test values('ha-%d')" % i)
    # 提交数据
    conn.commit()

if __name__ == "__main__":
    main()
```

* 查询
  * 开启运行时间的检测：
  ```
  set profiling=1;
  ```
  * 查找第1万条数据ha-99999
  ```
  select * from tb_test where title='ha-99999';
  ```
  * 查看执行的时间
  ```
  show profiles; # 耗时0.06s
  ```
  * 为表tb_test的title列创建索引
  ```
  create index tb_test on tb_test(title(10));
  ```
  * 执行查询语句
  ```
  select * from tb_test where title='ha-99999';
  ```
  * 再次查看执行时间
  ```
  show profiles; # 耗时0.03s
  ```
* 通过上述的demo执行时间可得出结论：
  * 索引可提升表查找的效率

* **注意**：索引并不是建立的越多越好
  * 建立索引会占用磁盘空间；
  * 建立太多的索引将会影响更新和插入的速度，因为它需要同步更新每个索引文件；
  * 对于较小的表，不推荐建立索引。

### 4. 账户管理
> 生产环境操作数据库，绝对不可以使用root账户连接，而是创建特定的账户。该账户的操作主要就是对数据的增删改查。

#### 4.1 账户体系简单说明
* MySQL的账户体系：根据账户所具有的权限级别不同分为以下几种：
  * **服务实例级账号**：启动一个mysql,如root,它拥有服务实例级分配的权限，可删除所有数据库和库中的表。
  * **数据库级别账号**：对特定数据库执行增删改查的操作；
  * **数据表级别账号**：对特定数据表执行增删改查的操作；
  * **字段级别权限的账号**：对某些表的特定字段进行操作；
  * **存储程序级别的账号**：对存储程序进行增删改查操作。
* 账户的操作主要包括：创建账户、删除账户、修改密码、授权权限等。
* 注意：
  * 账户操作需要使用root账户登录；
  * 通常都使用数据库级别账号的操作权限。

#### 4.2 账户操作
* 查看所有账户
  * 所有用户权限信息存储在mysql数据库的user中
  ```
  - 查看表结构
  desc user
  
  - 查看所有用户
  select host,user,authentication_string from user;
  
  - 主要字段的说明：
  host -> 表示允许访问的主机
  user -> 表示用户名
  authentication_string -> 表示密码，为加密后的值。
  ```
* 

### 5. MySQL主从

[回到顶部](#back-top)