<a id="back-top"></a>
[TOC]
### 1. 视图
> 思考一个问题：之前已上线的项目中已多处使用数据库的sql语句，现在因为需求变化等原因，数据库要做点改变，为了保证正常查询到数据，之前的功能代码也要进行多处更改，维护起来显然特别麻烦。这肯定是个问题，你会怎么解决呢？

> 答：解决办法：定义视图。（请带着疑惑继续看下去）

#### 1.1 视图是什么？
* 简言之，**视图**是一个sql语句生成的一张虚表！
* 语法：**`create view 视图名称 as select语句`**
* 注意：建议上述sql语句的**视图名称**建议以 **`v_`** 开头；
* **视图是对若干张基本表的引用，是一张虚表；这条sql语句执行的结果不存储具体的数据（基本表数据发生了改变，视图也会跟着改变）**
* 删除视图：`drop view 视图名称`

#### 1.2 视图的一个重要用途
* 我们已知**视图是一张虚表**，它的重要用途就是**查询**
```
-- 以 students 表 和classes 表为例
-- 创建 一张整合students 和 classes 整合的虚表
create view v_students_classes as select * from students as s left join classes as c where c.id = s.cls_id;

-- 使用视图
select * from v_students_classes;
```
#### 1.3 视图的优点
* 提高重用性，创建一张虚表，有需要的地方都可以使用这张表；
* 当需要重构数据库时，不需要修改程序中的sql语句；
* 不同用户使用不同的视图，提高数据安全性；
* 将多张基础表的数据整理到一张表，可直观查看数据。

### 2. 事务
> **事务** 在日常的代码程序中经常被使用；

#### 2.1 基本概念及特性
* 所谓**事务**，它是一个操作序列（即几个sql语句），这些操作要么都执行，要么都不执行，事务是一个不可分割的工作单位。
```
这里举一个银行转账的例子辅助理解：
小明向小东转账1000元
那么后台系统操作sql语句需要做以下几件事：
（1）检查小明的账户余额 >= 1000 元
（2）小明账户扣除 1000 元
（3）小东账户增加 1000 元

上述例子中，后台系统需要做的三件事就组成一个事务，只有这三步全部完成，
才能算转账成功，否则就会回滚到转账之前，提醒小明转账失败。
```
* 事务的四大特性(简称ACID)
  * 原子性
  * 一致性
  * 隔离性
  * 持久性
> 还是以上述的银行转账为例
```sql
- 1. 开启事务 begin 或者 start transaction;
start transaction;

- 2. 检查小明的账户余额 >= 1000
select * from v_bank_demo where id=141234;

- 3. 小明账户扣除1000
update table bank_demo set money = money-1000 where id=141234;

- 4. 小东账户增加1000元
update table bank_demo set money = money+1000 where id=214234;

- 5. 提交
commit;
```
* 上述的第2~4步，是一个不可分割的最小单元，这就是**原子性**的体现；
* 上述的第2~4步，具有‘同生共死’的特点，这就是**一致性**；
* 假设有A和B两个用户同时操作数据库，当A执行了上述1~4步，如果不执行第5步，B无法看到A对数据库的操作，这就体现为**隔离性**；
* 当执行第5步后，对数据库的操作会写入磁盘永久存储，这就是**持久性**。

#### 2.2 提交 `commit`
* 将缓存中的数据变更维护到物理表中；
* 使用`commit;`命令；

#### 2.3 回滚 `rollback`
* 放弃缓存中变更的数据;
* 使用`rollback;`命令；

### 3. 索引
> 数据的更新及插入操作很少出现性能问题，最多、最易出现问题的还是查询操作，因此对查询语句的优化是解决性能问题的重点。

> 提出一个问题：当遇到查询数据量很大时，查询速度会非常慢，如何解决？  答：索引。

#### 3.1 索引是什么
* 索引是一种特殊的文件，它们包含着对数据表里所有记录的引用指针。
* 通俗的说，数据库索引好比是一本书前面的目录，能加快数据库的查询速度。

#### 3.2 索引的目的
* 提升查询效率

#### 3.3 索引的使用
##### 3.3.1 查看索引
`show index from 表名;`

##### 3.3.2 创建索引
`create index 索引名称 on 表名(字段名称(长度));`
* 如果指定字段是字符串，需要指定长度，建议长度与定义字段时的长度一致；
* 字段类型如果不是字符串，可以不填写长度部分。

##### 3.3.3 删除索引
`drop index 索引名称 on 表名;`

#### 3.4 索引demo


### 4. 账户管理

### 5. MySQL主从

[回到顶部](#back-top)