<a id="back-top"></a>
[TOC]

### 1. 数据库的简介
#### 1.1 数据库
* 一种特殊的文件，主要用于存储文件。
#### 1.2 RDBMS 和 SQL
* **RDBMS**：关系型数据管理系统，目前常用的关系型数据管理系统有：Oracle、MySQL等
* **SQL**：用来操作RDBMS的数据库语言，当前关系型数据库都支持使用SQL语言进行操作
  * 常用SQL语句：
    * **DQL**：数据查询语言，用于对数据进行查询，如select;
    * **DML**：对数据进行增加、修改、删除，如insert、update、delete;
    * TPL：事务处理语言，对事务进行处理，包括begin、tansaction、commit、rollback;
    * DCL：数据控制语言，进行授权与权限回收，如grant、revoke;
    * DDL：数据定义语言，进行数据库、表的管理等，如create、drop;
    * CCL：指针控制语言，通过控制指针完成表的操作，如declare cursor。
  * SQL是一门特殊的语言，专门用来操作关系数据库
  * **不区分大小写**

### 2. 数据库的安装
[MySQL数据库安装配置](https://www.cnblogs.com/SamWeb/p/7922490.html) - 作者：SamWeb

### 3. 数据的完整性
* 一个数据库就是一个完整的业务单元，包含多张表，数据被存储在表中；
* 为了更加准确的储存数据，需要给SQL语句添加一些验证，比如数据字段的类型、约束。

#### 3.1 数据类型
* 使用数据类型的原则是：**够用就行，尽量使用取值范围小的，而不用大的，这样可以更多的节省存储空间**
* 常用数据类型如下：
  * 整数：int,bit;
  * 小数：decimal;
  * 字符串：varchar、char、text;
  * 日期时间：date,time,datetime;
  * 枚举类型：enum;
* 部分数据类型特殊说明：
  * decimal 表示浮点数，如decimal(5,2)表示共存5位数，小数占2位；
  * 字符串text表示存储大文本，当字符大于4000时推荐使用
  * 对于图片、音频、视频等文件，不存储在数据库中，而是上传到某个服务器上，然后在表中存储这个文件的保存路径
* 查看完整介绍[：MySQL 中的数据类型介绍](https://blog.csdn.net/anxpp/article/details/51284106) - 作者：anxpp

#### 3.2 约束
* **primary key**: 主键；
* **not null**：不为空；
* **auto_increament**：自增；
* **unique**：唯一；
* **default**：默认；
* **foreign key**：外键；
  * 在进行数据的crud(增删改查)时，使用外键会降低数据库的性能，所以不推荐使用。

> 数值类型（常用）

类型 | 字节大小 | 有符号范围(Signed) | 无符号范围(Unsigned)
---|---|---|---
TINYINT | 1 | -128 ~ 127 | 0 ~ 255
SMALLINT | 2 | -32768 ~ 32767 | 0 ~ 65535
MEDIUMINT | 3 | -8388608 ~ 8388607 | 0 ~ 16777215
INT/INTEGER | 4 | -2147483648 ~2147483647 | 0 ~ 4294967295
BIGIN |	8 | -9223372036854775808 ~ 9223372036854775807 | 0 ~ 18446744073709551615

> 日期时间类型

类型 | 字节大小 | 示例
---|---|---
DATE | 4 | '2020-01-01'
TIME | 3 | '12:29:59'
DATETIME | 8 | '2020-01-01 12:29:59'
YEAR | 1 | '2017'
TIMESTAMP | 4 | '1970-01-01 00:00:01' UTC ~ '2038-01-01 00:00:01' UTC


### 4. 数据库的设计
* 关系型数据库常在E-R模型的基础上，制定出表结构，这是项目开始的第一步。

#### 4.1 三范式
* 经过前人的研究和总结，对设计数据库提出了一些规范，这些规范被称为范式(Normal Form)；
* 目前有迹可循的共有8种范式，一般需要遵循3范式即可；

#### 4.2 第一范式(1NF)
* **强调列的原子性，即列不能够再分成其他几列**；
* 第一范式得出的结论就是**拆字段**。
* 举例
> 假设为某饭店设计一张数据库会员表

id | 联系人 | ...
---|---|---
0 | 张三、男、12300000000 | ...

  * 上表对字段**联系人**的设计就不遵循**第一范式（1NF）**
  * 这种设计的弊端之一：不利于修改。比如以后该会员手机号换了，我们自然需要更新手机号，这时就不方便了。
  * 针对上表的修改如下，使其符合**1NF**，

id | 姓名 | 性别 | 电话 | ...
---|---|---|---|---
0 | 张三 | 男 | 12300000000 | ...
  * 这样后期需要修改某条记录的某个字段信息也很方便。

[回到顶部](#back-top)

#### 4.3 第二范式(2NF)
* 在满足1NF的基础上，另外包含两个内容，**一是表必须有一个主键，二是没有包含在主键中的列必须完全依赖于主键，而不能只依赖于主键的一部分**。
* 这句话透出一个意思：**一个主键可能有不止一个字段构成，可能由多个字段构成**。
* 第二范式得出的结论是**拆表**。
* 举例
> 假设为某饭店设计一张数据库订单表
* 注意：一个订单中一定可以包含多份产品，对吧

订单id | 菜品id | 折扣 | 菜类型 | 单价 | ...
---|---|---|---|---|---
1002 | 7890 | 0.9 | 川菜 | 19.00 | ... 
1002 | 7891 | 0.85 | 湘菜 | 19.90 | ... 

* 上表很明显单单一个订单id不足以成为主键，需要和菜品id组合成为主键。
* 上表的设计符合1NF；
* 上表**折扣**字段完全依赖于主键（订单id和菜品id的组合），但是**菜类型**、**单价**仅仅依赖于**菜品id**,而不依赖**订单id**，根据2NF，**菜类型**、**单价**只依赖主键的一部分，这很明显不符合要求；
* 不符合 2NF 的设计容易产生冗余数据。
* * 针对上表的修改如下，使其符合**2NF**

> 创建订单表

订单id | 菜品id | 折扣 | ...
---|---|---|---
1002 | 7890 | 0.9 | ...
1002 | 7891 | 0.85 | ...

> 创建菜品表

菜品id | 菜类型 | 单价 | ...
---|---|---|---
7890 | 川菜 | 19.00 | ... 
7891 | 湘菜 | 19.90 | ... 

* 经过拆表后，新的两张表的设计符合**2NF**;

#### 4.4 第三范式(3NF)
* 在满足2NF的基础上，**另外非主键列必须直接依赖于主键，不能存在传递依赖**。即不能存在：**非主键列 A 依赖于非主键列 B，非主键列 B 依赖于主键的情况。**
* 举例

> 假设以该酒店的菜品表为例

菜品id | 菜类型 | 单价 | 厨师 | 厨师评级 | 厨师年龄 | ...
---|---|---|---|---|---|---
7890 | 川菜 | 19.00 | 李四 | 川菜一哥 | 20 | ... 
7891 | 湘菜 | 19.90 | 王五 | 湘菜一哥 | 21 | ...

* 该表非主键列都完全依赖于主键，多以符合`2NF`;
* 但是字段**厨师评级**、**厨师年龄**并没有直接依赖于主键而是依赖非主键**厨师**，根据**3NF**，非主键列必须直接依赖于主键，不能存在传递依赖，所以该表的设计不符合**3NF**；
* 因此对该表改进如下

> 菜品表

菜品id | 菜类型 | 单价 | 厨师id | ...
---|---|---|---|---
7890 | 川菜 | 19.00 | 23 | ... 
7891 | 湘菜 | 19.90 | 24 | ...

> 厨师表

厨师id | 姓名 | 厨师评价 | 厨师年龄 | ...
---|---|---|---|---
23 | 李四 | 川菜一哥 | 20 | ...
24 | 王五 | 湘菜一哥 | 21 | ...

* 经过如上表的拆分，将关于厨师的信息拆分成新的表;
* 这就使得符合**3NF**。
 

#### 4.5 从概念上区分**2NF**和**3NF**
* **2NF**：在满足1NF的基础上，另外包含两个内容，**一是表必须有一个主键，二是没有包含在主键中的列必须完全依赖于主键，而不能只依赖于主键的一部分**；
* **3NF**：在满足2NF的基础上，**另外非主键列必须直接依赖于主键，不能存在传递依赖**。即不能存在：**非主键列 A 依赖于非主键列 B，非主键列 B 依赖于主键的情况**。

[回到顶部](#back-top)